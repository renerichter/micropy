'''
All data generating functions will be found in here.
'''
import numpy as np
import NanoImagingPack as nip
from .transformations import irft3dz, rft3dz
from .utility import shiftby_list

# %%
# ------------------------------------------------------------------
#                       Parameter-generators
# ------------------------------------------------------------------


def PSF_SIM_PARA(para):
    '''
    Set standard-parameters for a PSF-simulation using the nip.PSF_PARAMS() set.

    PARAMS:
    ======
    :para:  (STRUCT) that can be generated by nip.PSF_PARAMS()

    OUTPUT:
    =======
    :para:  (STRUCT) changed param
    '''
    if para == None:
        para = nip.PSF_PARAMS()
    para.NA = 1.4
    para.n = 1.518
    para.lambdaEx = 488
    para.wavelength = 488
    para.pol = para.pols.lin
    para.pol_lin_angle = 0
    para.vectorized = False
    para.aplanar = para.apl.no
    para.aperture_method = 'jinc'


# %%
# ------------------------------------------------------------------
#                       TEST-OBJECT generators
# ------------------------------------------------------------------

def generate_testobj(test_object=3, mypath=''):
    '''
    Generates a 3D testobject depending on choice.
    '''
    if test_object == 0:
        im = nip.readim(mypath + 'images/chromo3d.ics')
    elif test_object == 1:
        a = nip.readim()
        im = nip.image(np.zeros([15, a.shape[0], a.shape[1]]))
        im[7] = a
        im[9] = np.rot90(a)
        im[3] = np.rot90(a, k=3)
    elif test_object == 2:
        # Test-target
        a = nip.readim()

        # get ROI -> first marks MAIN = central slice
        ROIs = [[160, 340, 285, 465], [58, 140, 174, 260],
                [390, 465, 210, 390], [60, 160, 300, 450]]
        b = []
        for m in ROIs:
            b.append(a[m[0]:m[1], m[2]:m[3]])
        b.append(np.rot90(b[1]))
        # for m in range(len(ROIs)):
        #    center = np.array(b[0].shape)- np.array(np.ceil(np.array(b[m].shape)/2),dtype=np.int)
        #    b[m] = nip.extract(b[m],ROIsize=[ROIs[0][1]-ROIs[0][0],ROIs[0][3]-ROIs[0][2]])

        # build image from ROIs
        im = nip.image(
            np.zeros((15, ROIs[0][1]-ROIs[0][0], ROIs[0][3]-ROIs[0][2])))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-3] = nip.extract(b[2], ROIsize=im.shape[1:])
        # im[imc-5] = nip.shift2Dby(im[imc-5],[np.floor(im.shape[1]/4.0),0])
        im[imc-2] = nip.extract(b[-2], ROIsize=im.shape[1:])
        im[imc-2] = nip.shift2Dby(im[imc-2], [np.floor(im.shape[1]/6.0), 0])
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]] = b[-1]
        im[imc] = b[0]
        im[imc+1, :b[1].shape[0], :b[1].shape[1]] = b[1]
        im[imc+1] = im[imc+1, ::-1, ::-1]
        im[imc+2] = nip.extract(b[2], ROIsize=im.shape[1:])
        im[imc+2] = nip.shift2Dby(im[imc+2], [-np.floor(im.shape[1]/4.0), 0])
        im[imc+3] = nip.extract(b[-2], ROIsize=im.shape[1:])

        # max-normalize the planes to the same uint8 max
        immax = im.max((-2, -1))
        immax[immax == 0] = 1
        im = im / immax[:, np.newaxis, np.newaxis]*np.iinfo('uint8').max
        im[im < 0] = 0
        # im[imc+5] = nip.shift2Dby(im[imc+5],[np.floor(im.shape[1]/6.0),0])
    elif test_object == 3:
        # Test-target
        a = nip.readim()

        # get ROI -> first marks MAIN = central slice
        ROIs = [[160, 340, 285, 465], [58, 140, 174, 260],
                [390, 465, 210, 390], [60, 160, 300, 450]]
        b = []
        for m in ROIs:
            b.append(a[m[0]:m[1], m[2]:m[3]])
        b.append(np.rot90(b[1]))

        # build image from ROIs
        im = nip.image(
            np.zeros((15, ROIs[0][1]-ROIs[0][0], ROIs[0][3]-ROIs[0][2])))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-3, int(im.shape[-2]/2.0):, :] = nip.xx([int(im.shape[-2]/2.0),
                                                       im.shape[-1]]) + nip.xx([int(im.shape[-2]/2.0), im.shape[-1]]).min()
        im[imc-2, int(im.shape[-2]/10.0):int(im.shape[-2]/10.0) + int(im.shape[-1]/2.0), int(im.shape[-1]/4.0):int(im.shape[-1]/4.0) + int(im.shape[-1]/2.0)
           ] = (nip.rr([int(im.shape[-2]/2.0), int(im.shape[-1]/2.0)]) <= int(im.shape[-2]/4.0))*1 * nip.rr([int(im.shape[-2]/2.0), int(im.shape[-1]/2.0)]) * 4
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]]
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]] = b[-1]
        im[imc] = b[0]
        im[imc+1, :b[1].shape[0], :b[1].shape[1]] = b[1]
        im[imc+1] = im[imc+1, ::-1, ::-1]
        im[imc+2] = nip.extract(b[2], ROIsize=im.shape[1:])
        im[imc+2] = nip.shift2Dby(im[imc+2], [-np.floor(im.shape[1]/4.0), 0])
        im[imc+3] = nip.extract(b[-2], ROIsize=im.shape[1:])

        # max-normalize the planes to the same uint8 max
        immax = im.max((-2, -1))
        immax[immax == 0] = 1
        im = im / immax[:, np.newaxis, np.newaxis]*np.iinfo('uint8').max
        im[im < 0] = 0
    elif test_object == 4:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc] = a
    elif test_object == 5:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc+1] = a
    elif test_object == 6:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-2] = a
    else:
        im = nip.readim('obj3d')[::2, :, :]

    return im


def ismR_defaultIMG(obj, psf, NPhot=None, use2D=True):
    '''
    Calculates Image using default forward model and Poisson-noise.
    '''
    # params
    objc = np.array(np.floor(np.array(obj.shape)/2.0), dtype=np.uint)

    # calculate image
    im_ism = forward_model(obj, psf)

    # select in-focus slice -> assume real-image and PSF
    if use2D:
        im_ism_sel = np.real(im_ism[:, objc[0]])

    # add Poisson-noise
    im_ism_sel /= np.max(im_ism_sel)
    if NPhot is not None:
        im_ism_sel = nip.poisson(im_ism_sel * NPhot)

    # provide transformed image
    im_ism_ft = nip.ft2d(im_ism_sel) if use2D else nip.ft3d(im_ism_sel)

    return im_ism_sel, im_ism_ft, objc
# %%
# ------------------------------------------------------------------
#                       PSF-generators
# ------------------------------------------------------------------


def ismR_defaultPSF(obj, lex=488, lem=520, shift_offset=[2, 2], nbr_det=[3, 3]):
    # generate PSFs
    para = nip.PSF_PARAMS()
    PSF_SIM_PARA(para)  # add formerly defined PSF-paramaters

    # non-aberrated excitation
    para.lambdaEx = 488
    para.wavelength = 488
    para.aplanar = para.apl.excitation
    psfex = nip.psf(obj, para)

    # non-aberrated emission
    para.lambdaEx = 520
    para.wavelength = 520
    para.aplanar = para.apl.emission
    psfem = nip.psf(obj, para)

    # generate ISM total PSF and normalize to 1 (because if there is a photon reaching the detector it will be detected)
    psfem_array = shiftby_list(
        psfem, shift_offset=shift_offset, nbr_det=nbr_det)
    psf_eff = psfex[np.newaxis] * np.real(psfem_array)
    psf_eff /= np.sum(psf_eff, keepdims=True)
    otf_eff = rft3dz(psf_eff)

    # centers
    psfc = np.array(np.floor(np.array(psf_eff.shape)/2.0), dtype=np.uint)

    return psf_eff, otf_eff, psfc


# %%
# ------------------------------------------------------------------
#                       FWD-Model
# ------------------------------------------------------------------

def forward_model(obj, psf, fmodel='fft', retreal=True, is_list=False,**kwargs):
    '''
    A simple forward model calculation using either fft or rft.

    :PARAMS:
    =======
    :obj:       (IMAGE) real image input
    :psf:       (IMAGE) real psf input
    :fmodel:    (STRING) 'fft' or 'rft'
    :retreal:   (BOOL) wether output should be real

    :OUTPUT:
    ========
    :res:       (IMAGE) simulated image
    '''
    if fmodel == 'fft':
        # normalization for 3dim ortho-convolution normalization on last 3 axes
        res = nip.ift3d(nip.ft3d(
            obj[np.newaxis])*nip.ft3d(psf)) * np.sqrt(np.prod(list(psf.shape[-3:]))) * np.sqrt(np.prod(psf.shape[-3:]))
    else:
        # normalization for 2dim ortho-convolution on last 2 (=fft) axes; RFT is automatically ok due to only normalizing in back-path
        res = irft3dz(rft3dz(obj[np.newaxis])*rft3dz(psf),
                      s=psf.shape) * np.sqrt(np.prod(psf.shape[-2:]))

    if retreal:
        res = res.real

    return res
