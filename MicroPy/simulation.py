'''
All data generating functions will be found in here.
'''
import numpy as np
import NanoImagingPack as nip
import copy
from .transformations import irft3dz, rft3dz
from .utility import shiftby_list

# %%
# ------------------------------------------------------------------
#                       Parameter-generators
# ------------------------------------------------------------------


def PSF_SIM_PARA(para):
    '''
    Set standard-parameters for a PSF-simulation using the nip.PSF_PARAMS() set.

    PARAMS:
    ======
    :para:  (STRUCT) that can be generated by nip.PSF_PARAMS()

    OUTPUT:
    =======
    :para:  (STRUCT) changed param
    '''
    if para == None:
        para = nip.PSF_PARAMS()
    para.NA = 1.4
    para.n = 1.518
    para.lambdaEx = 488
    para.wavelength = 488
    para.pol = para.pols.lin
    para.pol_lin_angle = 0
    para.vectorized = False
    para.aplanar = para.apl.no
    para.aperture_method = 'jinc'

    # done?
    return para


# %%
# ------------------------------------------------------------------
#                       TEST-OBJECT generators
# ------------------------------------------------------------------

def generate_testobj(test_object=3, mypath=''):
    '''
    Generates a 3D testobject depending on choice.
    '''
    if test_object == 0:
        im = nip.readim(mypath + 'images/chromo3d.ics')
    elif test_object == 1:
        a = nip.readim()
        im = nip.image(np.zeros([15, a.shape[0], a.shape[1]]))
        im[7] = a
        im[9] = np.rot90(a)
        im[3] = np.rot90(a, k=3)
    elif test_object == 2:
        # Test-target
        a = nip.readim()

        # get ROI -> first marks MAIN = central slice
        ROIs = [[160, 340, 285, 465], [58, 140, 174, 260],
                [390, 465, 210, 390], [60, 160, 300, 450]]
        b = []
        for m in ROIs:
            b.append(a[m[0]:m[1], m[2]:m[3]])
        b.append(np.rot90(b[1]))
        # for m in range(len(ROIs)):
        #    center = np.array(b[0].shape)- np.array(np.ceil(np.array(b[m].shape)/2),dtype=np.int)
        #    b[m] = nip.extract(b[m],ROIsize=[ROIs[0][1]-ROIs[0][0],ROIs[0][3]-ROIs[0][2]])

        # build image from ROIs
        im = nip.image(
            np.zeros((15, ROIs[0][1]-ROIs[0][0], ROIs[0][3]-ROIs[0][2])))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-3] = nip.extract(b[2], ROIsize=im.shape[1:])
        # im[imc-5] = nip.shift2Dby(im[imc-5],[np.floor(im.shape[1]/4.0),0])
        im[imc-2] = nip.extract(b[-2], ROIsize=im.shape[1:])
        im[imc-2] = nip.shift2Dby(im[imc-2], [np.floor(im.shape[1]/6.0), 0])
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]] = b[-1]
        im[imc] = b[0]
        im[imc+1, :b[1].shape[0], :b[1].shape[1]] = b[1]
        im[imc+1] = im[imc+1, ::-1, ::-1]
        im[imc+2] = nip.extract(b[2], ROIsize=im.shape[1:])
        im[imc+2] = nip.shift2Dby(im[imc+2], [-np.floor(im.shape[1]/4.0), 0])
        im[imc+3] = nip.extract(b[-2], ROIsize=im.shape[1:])

        # max-normalize the planes to the same uint8 max
        immax = im.max((-2, -1))
        immax[immax == 0] = 1
        im = im / immax[:, np.newaxis, np.newaxis]*np.iinfo('uint8').max
        im[im < 0] = 0
        # im[imc+5] = nip.shift2Dby(im[imc+5],[np.floor(im.shape[1]/6.0),0])
    elif test_object == 3:
        # Test-target
        a = nip.readim()

        # get ROI -> first marks MAIN = central slice
        ROIs = [[160, 340, 285, 465], [58, 140, 174, 260],
                [390, 465, 210, 390], [60, 160, 300, 450]]
        b = []
        for m in ROIs:
            b.append(a[m[0]:m[1], m[2]:m[3]])
        b.append(np.rot90(b[1]))

        # build image from ROIs
        im = nip.image(
            np.zeros((15, ROIs[0][1]-ROIs[0][0], ROIs[0][3]-ROIs[0][2])))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-3, int(im.shape[-2]/2.0):, :] = nip.xx([int(im.shape[-2]/2.0),
                                                       im.shape[-1]]) + nip.xx([int(im.shape[-2]/2.0), im.shape[-1]]).min()
        im[imc-2, int(im.shape[-2]/10.0):int(im.shape[-2]/10.0) + int(im.shape[-1]/2.0), int(im.shape[-1]/4.0):int(im.shape[-1]/4.0) + int(im.shape[-1]/2.0)
           ] = (nip.rr([int(im.shape[-2]/2.0), int(im.shape[-1]/2.0)]) <= int(im.shape[-2]/4.0))*1 * nip.rr([int(im.shape[-2]/2.0), int(im.shape[-1]/2.0)]) * 4
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]]
        im[imc-1, :b[-1].shape[0], :b[-1].shape[1]] = b[-1]
        im[imc] = b[0]
        im[imc+1, :b[1].shape[0], :b[1].shape[1]] = b[1]
        im[imc+1] = im[imc+1, ::-1, ::-1]
        im[imc+2] = nip.extract(b[2], ROIsize=im.shape[1:])
        im[imc+2] = nip.shift2Dby(im[imc+2], [-np.floor(im.shape[1]/4.0), 0])
        im[imc+3] = nip.extract(b[-2], ROIsize=im.shape[1:])

        # max-normalize the planes to the same uint8 max
        immax = im.max((-2, -1))
        immax[immax == 0] = 1
        im = im / immax[:, np.newaxis, np.newaxis]*np.iinfo('uint8').max
        im[im < 0] = 0
    elif test_object == 4:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc] = a
    elif test_object == 5:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc+1] = a
    elif test_object == 6:
        a = nip.readim()[160:340, 285:465]
        im = nip.image(np.zeros([16, a.shape[0], a.shape[1]]))
        imc = int(np.floor(im.shape[0]/2.0))
        im[imc-2] = a
    else:
        im = nip.readim('obj3d')[::2, :, :]

    return im


def ismR_defaultIMG(obj, psf, NPhot=None, use2D=True):
    '''
    Calculates Image using default forward model and Poisson-noise.
    '''
    # params
    objc = np.array(np.floor(np.array(obj.shape)/2.0), dtype=np.uint)

    # calculate image
    im_ism = forward_model(obj, psf)

    # select in-focus slice -> assume real-image and PSF
    if use2D:
        im_ism_sel = np.real(im_ism[:, objc[0]])

    # add Poisson-noise
    im_ism_sel /= np.max(im_ism_sel)
    if NPhot is not None:
        im_ism_sel = nip.poisson(im_ism_sel * NPhot)

    # provide transformed image
    im_ism_ft = nip.ft2d(im_ism_sel) if use2D else nip.ft3d(im_ism_sel)

    return im_ism_sel, im_ism_ft, objc
# %%
# ------------------------------------------------------------------
#                       PSF-generators
# ------------------------------------------------------------------
def calculatePSF_confocal(obj,psf_params,psfp=False):
    '''
    Calculates confocal PSF. 
    See calculatePSF for explanation on parameters
    '''
    psfex = nip.psf(obj,psf_params[0])
    if not psfp:
        psf_params.append(copy.deepcopy(psf_params[0]))
        psf_params[1].wavelength = 510
        psf_params[1].pinhole = 0.6
    psfem = nip.psf(obj,psf_params[1])
    pinhole = generate_pinhole(psfem,psf_params[1])
    psf = psfex * nip.convolve(psfem,pinhole)

    # done?
    return psf


def calculatePSF(obj,psf_params=None,method='brightfield',amplitude=False):
    '''
    Calculates different PSFs according to the selected method. 

    :PARAMS:
    ========
    :im:            (IMAGE) object-image to provide shape and pixel-size
    :psf_params:    (LIST) of STRUCTS from nip.PSF_PARAMS-type -> contains all necessary simulation parameters 
    :method:        (STRING) method to be used. Options are:
                'brightfield': standard PSF_em
                'confocal': PSF_ex * CONV(PSF_em,Pinhole)
                '2photon': (PSF_ex*PSF_ex) * PSF
                'ism': CONV(PSF_ex,detector_geometry)*PSF_em
                'dsax': PSF^sat_ex * PSF_em
                'dsaxISM': CONV(PSF^sat_ex,detector_geometry) * PSF_em
                'sim':  to be done
                'light-sheet': to be done
                'ptychography': to  be done
    :amplitude:     (BOOL) if true, returns amplitude PSF

    :OUTPUT:
    ========
    :psf:       (IMAGE) calculated (a)psf

    :EXAMPLE:
    =========
    psfpara = nip.PSF_PARAMS()
    psfpara.wavelength = 488
    psfpara.NA = 1.4
    psfpara.n = 1.518
    psfpara.pinhole = 0.6 # in Airy-Units of PSFem (widefield)
    psfparams=[psfpara,psfpara]
    psf = calculatePSF(im,psf_params=psfparams,method='confocal',amplitude=False)

    '''
    psfp = False
    if psf_params==None:
        psf_params = nip.PSF_PARAMS()
        psf_params.wavelength = 488
        psf_params.NA = 1.4
        psf_params.n = 1.518
        psf_params = [psf_params,]
    else:
        psfp = True

    if method=='brightfield':
        psf = nip.psf(obj,psf_params[0])
    elif method == 'confocal':
        psf = calculatePSF_confocal(obj=obj,psf_params=psf_params,psfp=psfp)
    elif method == '2photon':
        pass
    elif method == 'ism':
        pass
    elif method == 'dsax':
        pass
    elif method == 'dsaxISM':
        pass
    elif method == 'SIM':
        pass
    elif method == 'ptychography':
        pass
    else: 
        raise ValueError('Method not implemented yet.')

    # done?
    return psf
    
def generate_pinhole(psf,psf_params,pshape='circular',pedge='hard'):
    '''
    Calculates and generates a pinhole from the simulation properties.
    
    :PARAMS:
    ========
    :psf:           (IMAGE) PSF to provide shape and pixel-size
    :psf_params:    (LIST) of STRUCTS from nip.PSF_PARAMS-type -> contains all necessary simulation parameters 
    :pshape:        (STRING) possible shapes for pinhole
                    'circular': 
                    'rect': rectangular pinhole -> to be implemented
                    'hexagon': hexagonal pinhole-> to be implemented
    :pedge:         (STRING) properties of pinhole edges 
                    'hard': just a hard edge
                    'gauss': gaussian damped edge -> to be implemented
                    'sinc': sinc damped edge -> to be implemented
                    'invgauss': gaussian increased edges -> to be implemented

    :OUTPUT:
    ========
    :pinhole:       (IMAGE) calculated pinhole

    :EXAMPLE:
    =========
    
    '''
    # pinhole-size from theoretical AU by: 1.22 * lambda / NA
    airyUNIT =  1.22 * psf_params.wavelength / psf_params.NA
    pinhole_radius = psf_params.pinhole * airyUNIT / (2 * np.array(psf.pixelsize[-2:]))

    if pshape=='circular':
        pinhole = nip.rr(psf.shape) <= pinhole_radius[-1]
    else:
        raise ValueError(f"Used pshape={pshape} not implemented yet ")

    if pedge == 'hard':
        pass
    else:
        raise ValueError(f"Used pedge={pedge} not implemented yet ")
    
    # done?
    return pinhole

def ismR_defaultPSF(obj, lex=488, lem=520, shift_offset=[2, 2], nbr_det=[3, 3]):
    # generate PSFs
    para = nip.PSF_PARAMS()
    PSF_SIM_PARA(para)  # add formerly defined PSF-paramaters

    # non-aberrated excitation
    para.lambdaEx = 488
    para.wavelength = 488
    para.aplanar = para.apl.excitation
    psfex = nip.psf(obj, para)

    # non-aberrated emission
    para.lambdaEx = 520
    para.wavelength = 520
    para.aplanar = para.apl.emission
    psfem = nip.psf(obj, para)

    # generate ISM total PSF and normalize to 1 (because if there is a photon reaching the detector it will be detected)
    psfem_array = shiftby_list(
        psfem, shift_offset=shift_offset, nbr_det=nbr_det)
    psf_eff = psfex[np.newaxis] * np.real(psfem_array)
    psf_eff /= np.sum(psf_eff, keepdims=True)
    otf_eff = rft3dz(psf_eff)

    # centers
    psfc = np.array(np.floor(np.array(psf_eff.shape)/2.0), dtype=np.uint)

    return psf_eff, otf_eff, psfc


# %%
# ------------------------------------------------------------------
#                       FWD-Model
# ------------------------------------------------------------------

def forward_model(obj, psf, fmodel='fft', retreal=True, is_list=False,**kwargs):
    '''
    A simple forward model calculation using either fft or rft.

    :PARAMS:
    =======
    :obj:       (IMAGE) real image input
    :psf:       (IMAGE) real psf input
    :fmodel:    (STRING) 'fft' or 'rft'
    :retreal:   (BOOL) wether output should be real

    :OUTPUT:
    ========
    :res:       (IMAGE) simulated image
    '''
    if fmodel == 'fft':
        # normalization for 3dim ortho-convolution normalization on last 3 axes
        res = nip.ift3d(nip.ft3d(
            obj[np.newaxis])*nip.ft3d(psf)) * np.sqrt(np.prod(list(psf.shape[-3:]))) * np.sqrt(np.prod(psf.shape[-3:]))
    else:
        # normalization for 2dim ortho-convolution on last 2 (=fft) axes; RFT is automatically ok due to only normalizing in back-path
        res = irft3dz(rft3dz(obj[np.newaxis])*rft3dz(psf),
                      s=psf.shape) * np.sqrt(np.prod(psf.shape[-2:]))

    if retreal:
        res = res.real

    return res

# %%
# ------------------------------------------------------------------
#                       Noise-Generators
# ------------------------------------------------------------------

def add_symmetric_point(im,pos,val):
    '''
    Adds a symmetric point around the Fourier-origin. Takes evenness of image-sizes into account. For now: only works on same dimensionality of im and pos.

    Note: No boundary-checks etc done
    '''
    offsets = np.mod(np.array(im.shape),2)
    pos2 = tuple([(im.shape[m] - offsets[m]) - va for m,va in enumerate(pos)])
    im[pos] = val
    im[pos2] = val
    return im, pos2

def generate_pickupNoise(imshape,pickup_pos,pickup_level):
    '''
    Generates a pickupNoise-image.

    PARAMS:
    =======
    :imshape:       (TUPLE) shape of output-image
    :pickup_pos:    (LIST) of 
    :pickup_level:  (LIST) of values for pickup

    OUTPUTS:
    ========
    :im_pnFT:       (IMAGE) generated fourier-image
    :im_pn:         (IMAGE) noise-term-image
    :poslist:       (LIST) of Tuples with positions used

    EXAMPLE:
    ========
    im_pnFT, im_pn = generate_pickupNoise(imshape=(5,5,8),pickup_pos=[[2,3,4],[0,1,5]],pickup_level=[10,20])
    '''
    poslist = []
    im_pnFT = nip.image(np.zeros(imshape))
    for m,pos in enumerate(pickup_pos):
        pos = tuple(pos)
        im_pnFT,pos2 = add_symmetric_point(im_pnFT,pos,pickup_level[m])
        poslist.append([pos,pos2])
        im_pn = np.real(nip.ft(im_pnFT))
        im_pn -= np.min(im_pn,keepdims=True)
    
    #done?
    return im_pnFT, im_pn, poslist